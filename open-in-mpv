#!/usr/bin/env python
from __future__ import print_function
from __future__ import unicode_literals
from os.path import expanduser, isdir, exists, join as path_join
import json
import logging
import os
import socket
import struct
import subprocess as sp
import sys

DATA_PATH = expanduser('~/.local/share/open-in-mpv')
LOG = logging.getLogger('open-in-mpv')
MPV_SOCKET = expanduser('~/.cache/open-in-mpv.sock')
PY3 = sys.version_info.major == 3


def spawn(func):
    """See Stevens' "Advanced Programming in the UNIX Environment" for details
    (ISBN 0201563177)
    Credit: https://stackoverflow.com/a/6011298/374110

    Takes a callable which will be called in the fork.
    """
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as exc:
        LOG.exception('Fork #1 failed: %s (%s)', exc.errno, exc.strerror)
        sys.exit(1)

    os.setsid()
    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as exc:
        LOG.exception('Fork #2 failed: %s (%s)', exc.errno, exc.strerror)
        sys.exit(1)
    # Call the callback
    func()
    # Exit without calling cleanup handlers
    os._exit(os.EX_OK)


def spawn_init(url, log, new_env):
    LOG.debug('Spawning initial instance')
    spawn(lambda: sp.check_call([
        'mpv', '--quiet', '--player-operation-mode=pseudo-gui',
        '--input-ipc-server={}'.format(MPV_SOCKET), url
    ],
                                env=new_env,
                                stdout=log,
                                stderr=log))


def get_cb(url, log, new_env):
    def cb():
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            s.connect(MPV_SOCKET)
            s.send(
                json.dumps({
                    'command': ['loadfile', url]
                }).encode('utf-8', 'strict') + b'\n')
        except ConnectionRefusedError:
            LOG.exception('Connection refused')
            spawn_init(url, log, new_env)

    return cb


def main():
    try:
        os.makedirs(DATA_PATH)
    except OSError:
        pass
    out_log_path = path_join(DATA_PATH, 'native.log')
    log = open(out_log_path, 'a+')
    LOG.setLevel(logging.ERROR)
    LOG.addHandler(logging.StreamHandler(log))

    stdin_buffer = sys.stdin
    if PY3:
        stdin_buffer = sys.stdin.buffer
    req_len = struct.unpack('@i', stdin_buffer.read(4))[0]
    message = json.loads(stdin_buffer.read(req_len))

    LOG.debug('Message contents (%d): %s', req_len, message)

    try:
        url = message['url']
    except KeyError:
        LOG.exception('No URL was given')
        print(json.dumps({'message': 'Missing URL!'}))
        return 1

    # MacPorts
    new_env = os.environ.copy()
    data_resp = {
        'log_path': out_log_path,
        'py3': PY3,
        'message': 'About to spawn'
    }
    if isdir('/opt/local/bin'):
        print('Detected MacPorts. Setting PATH.', file=log)
        data_resp['macports'] = True
        old_path = os.environ.get('PATH')
        new_env['PATH'] = '/opt/local/bin' if not old_path else ':'.join(
            ['/opt/local/bin', old_path])
    data_resp['env'] = new_env

    LOG.debug('About to spawn')
    resp = json.dumps(data_resp)
    size = struct.pack('@i', len(resp))
    stdout_buffer = sys.stdout
    if PY3:
        stdout_buffer = sys.stdout.buffer
        resp = resp.encode('utf-8')
        size = struct.pack('@i', len(size))
    stdout_buffer.write(size)
    stdout_buffer.write(resp)

    if exists(MPV_SOCKET):
        spawn(get_cb(url, log, new_env))
    else:
        spawn_init(url, log, new_env)

    LOG.debug('mpv should open soon')
    LOG.debug('Exiting with status 0')
    log.close()

    return 0


if __name__ == '__main__':
    sys.exit(main())
