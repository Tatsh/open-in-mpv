#!/usr/bin/env python
from __future__ import print_function
from __future__ import unicode_literals
from os.path import expanduser, isdir, exists, join as path_join
import json
import os
import socket
import struct
import subprocess as sp
import sys

MPV_SOCKET = expanduser('~/.cache/open-in-mpv.sock')
DATA_PATH = expanduser('~/.local/share/open-in-mpv')
PY3 = sys.version_info.major == 3


def spawn(func):
    """See Stevens' "Advanced Programming in the UNIX Environment" for details
    (ISBN 0201563177)
    Credit: https://stackoverflow.com/a/6011298/374110

    Takes a callable which will be called in the fork.
    """
    try:
        pid = os.fork()
        if pid > 0:
            # parent process, return and keep running
            return
    except OSError as exc:
        print('Fork #1 failed: {} ({})'.format(exc.errno, exc.strerror))
        sys.exit(1)

    os.setsid()
    # do second fork
    try:
        pid = os.fork()
        if pid > 0:
            # exit from second parent
            sys.exit(0)
    except OSError as exc:
        print('Fork #2 failed: {} ({})'.format(exc.errno, exc.strerror))
        sys.exit(1)
    # Call the callback
    func()
    # Exit without calling cleanup handlers
    os._exit(os.EX_OK)


def spawn_init(url, log, new_env):
    print('Spawning initial instance', file=log)
    spawn(lambda: sp.check_call([
        'mpv', '--quiet', '--player-operation-mode=pseudo-gui',
        '--input-ipc-server={}'.format(MPV_SOCKET), url
    ],
                                env=new_env,
                                stdout=log,
                                stderr=log))


def get_cb(url, log, new_env):
    def cb():
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        try:
            s.connect(MPV_SOCKET)
            s.send(
                json.dumps({
                    'command': ['loadfile', url]
                }).encode('utf-8', 'strict') + b'\n')
        except ConnectionRefusedError:
            print('Connection refused', file=log)
            spawn_init(url, log, new_env)
    return cb


def main():
    try:
        os.makedirs(DATA_PATH)
    except OSError:
        pass
    out_log_path = path_join(DATA_PATH, 'native.log')
    log = open(out_log_path, 'a+')
    stdin_buffer = sys.stdin
    if PY3:
        stdin_buffer = sys.stdin.buffer
    req_len = struct.unpack('@i', stdin_buffer.read(4))[0]
    print('Message length: {}'.format(req_len), file=log)
    message = json.loads(stdin_buffer.read(req_len))
    print('Message contents: {}'.format(message), file=log)

    try:
        url = message['url']
    except KeyError:
        print(json.dumps({'message': 'Missing URL!'}))
        return 1

    # MacPorts
    new_env = os.environ.copy()
    data_resp = {
        'log_path': out_log_path,
        'py3': PY3,
        'message': 'About to spawn'
    }
    if isdir('/opt/local/bin'):
        print('Detected MacPorts. Setting PATH.', file=log)
        data_resp['macports'] = True
        try:
            old_path = os.environ['PATH']
            new_env['PATH'] = '/opt/local/bin:{}'.format(old_path)
        except KeyError:
            new_env['PATH'] = '/opt/local/bin'
    data_resp['env'] = new_env

    print('About to spawn', file=log)
    resp = json.dumps(data_resp)
    size = struct.pack('@i', len(resp))
    stdout_buffer = sys.stdout
    if PY3:
        stdout_buffer = sys.stdout.buffer
        resp = resp.encode('utf-8')
        size = struct.pack('@i', len(size))
    stdout_buffer.write(size)
    stdout_buffer.write(resp)

    if isdir('/Applications/MacPorts/mpv.app'):
        # mpv.app automatically restricts itself to one window
        spawn(lambda: sp.check_call(
            ['open', '-W', '/Applications/MacPorts/mpv.app', '--args', url],
            env=new_env,
            stdout=log,
            stderr=log))
    else:
        if exists(MPV_SOCKET):
            spawn(get_cb(url, log, new_env))
        else:
            spawn_init(url, log, new_env)

    print('mpv should open soon', file=log)
    print('Exiting with status 0', file=log)
    log.close()

    return 0


if __name__ == '__main__':
    sys.exit(main())
